package Kursi.P3_Sort;
/*
Задача, поставленная разработчику, звучит следующим образом:
Компания PineApple анализирует продажи подразделений, расположенных в разных странах, на определенную дату.
Аналитикам компании необходима возможность отсортировать подразделения по возрастанию объемов продаж.
Необходимо в приложение добавить статический метод sortSales, который не возвращает значение,
но сортирует данные о продажах. В метод sortSales должны передаваться два массива данных:
Массив названий стран подразделений (строки);
Массив данных о продажах (действительные числа).
Данные, которые будут передаваться в метод, по умолчанию синхронизированы
(0-й элемент массива данных о продажах соответствует 0-му элементу массива стран, 1-й - 1-му и т.д.).

Необходимо реализовать следующую логику работы метода:

Если в метод были переданы поврежденные данные (размеры массивов не соответствуют друг другу),
необходимо вывести на консоль сообщение "Corrupted Data" и не выполнять сортировки;
Если в метод  были переданы пустые массивы, необходимо вывести на консоль сообщение "Empty Data" и не выполнять сортировки;
Во всех остальных случаях необходимо выполнить сортировку обоих массивов с учетом следующих требований:
необходимо использовать двунаправленный алгоритм сортировки выбором,
в котором за один проход одновременно находятся и переставляются максимальный элемент (в конец неотсортированной части массива)
и минимальный элемент (в начало неотсортированной части массива);
сортировку необходимо провести синхронно, т. е. если осуществляется перестановка значений в массиве данных о продажах,
должна осуществляться аналогичная (по индексам) перестановка в массиве названий стран;
после каждой двунаправленной перестановки необходимо выводить на консоль все содержимое обоих массивов
с помощью метода printData (см. примечания);
после завершения сортировки необходимо вывести на консоль все содержимое обоих массивов с помощью метода printData.

Приведи фрагмент кода, который определяет публичный статичный метод sortSales в соответствии с приведенным описанием задачи.

Примечание 1. Твой фрагмент кода будет проверяться автоматически, поэтому убедись, что в нем не содержатся синтаксические ошибки.
Примечание 2. Не забудь добавить комментарии к фрагменту кода, в которых ты объясняешь суть алгоритма.
Примечание 3. Для вывода содержания массивов в консоль скопируй себе и используй метод printData: */

class Sort_2_Choice {
    private static void printData(String[] names, double[] data) { // метод для вывода
        System.out.print("{");
        for (int i = 0; i < names.length; i++) System.out.print(names[i] + ": " + data[i] + ", ");
        System.out.println("\b\b}");
    }

    public static void sortSales(String[] names, double[] data) { // метод сортировки выбором (двунаправленный
        if (names.length != data.length) {             // Если размеры массивов не равны друг другу, то
            System.out.println("Corrupted Data");      // выводим сообшение, согласно п.1 задачи и
            return;                                    // прекращаем работу метода.
        }
        if (names.length == 0) {   // Если массивы не содержат данных, то
            System.out.println("Empty Data");          // выводим сообшение, согласно п.2 задачи и
            return;                                    // прекращаем работу метода.
        }
        // Проходим циклом от 1го до последнего элемента массива в 1й итерации, от 2го до предпоследнего во 2й и т.д.
        for (int i = 0, j = data.length - 1; i < j; i++, j--) {
            int maxId = i, minId = i;                                // Пермеменная индекса макc. и мин. элемента массива
            double maxData = data[maxId], minData = data[minId];     // Переменная макс. и мин. элемента массива date
            String maxNames = names[maxId], minNames = names[minId]; // Переменная макс. и мин. элемента массива names
            for (int k = i; k <= j; k++) {    // Проходим циклом с i-го до j-го элемента включительно
                if (data[k] > maxData) {      // Если текущий элемент больше максимального то,
                    maxData = data[k];        // текущий элемент массива data считаем максимальным,
                    maxNames = names[k];      // текущий элемент массива data считаем максимальным
                    maxId = k;                // Текущий индекс максимального элемента
                } else if (data[k] < minData) { // Если текущий элемент меньше минимального то,
                    minData = data[k];        // текущий элемент массива data считаем минимальным,
                    minNames = names[k];      // текущий элемент массива names считаем минимальным
                    minId = k;                // Текущий индекс минимального элемента
                }
            }
            // Производим перестановку последнего элемента с максимальным, за вычетом j-й итерации
            data[maxId] = data[j];
            names[maxId] = names[j];
            data[j] = maxData;
            names[j] = maxNames;
            // Если мин. элемент находится в конце массива, то после перестановки он поменяет свое положение
            if (minId == j)    // Если данное условие верно, то
                minId = maxId; // изменяем текущий индекс мин. элемента
            // Производим перестановку первого элемента с минимальным, c прибавлением i-й итерации
            data[minId] = data[i];
            names[minId] = names[i];
            data[i] = minData;
            names[i] = minNames;
            printData(names, data); // После каждой перестановки выводим сообщение, согласно п.3 задачи
        }
    }
}
