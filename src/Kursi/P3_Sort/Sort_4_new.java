package Kursi.P3_Sort;

/* Необходимо переписать метод sortSales таким образом, чтобы его производительность не зависела от количества
анализируемых данных в диапазоне от 1 до 40000 элементов.
Таким образом, требования к методу sortSales сформулированы следующим образом:

Метод должен сортировать данные по возрастанию объемов продаж.
Метод должен принимать массив строк, содержащих наименование/идентификатор анализируемой бизнес-единицы
(это может быть как страна, так и отдельный магазин) в качестве первого параметра.
Метод должен принимать массив double, содержащий значение объема продаж для соответствующей бизнес-единицы,
в качестве второго параметра.
Данные, которые будут передаваться в метод, по умолчанию синхронизированы
Если размеры массивов не соответствуют друг другу - вывести сообщение "Corrupted Data" и не выполнять сортировки.
Если пустые массивы, необходимо вывести сообщение "Empty Data" и не выполнять сортировки.
Во всех остальных случаях необходимо выполнить сортировку обоих массивов с учетом следующих требований:
алгоритм сортировки должен выполняться полностью не дольше 0,2 секунд;
сортировка должна происходить синхронно, т. е. если осуществляется перестановка значений в массиве данных о продажах,
должна осуществляться аналогичная (по индексам) перестановка в массиве названий/идентификаторов бизнес-единиц;
вывод массивов на консоль должен осуществляться с помощью метода printData (см. ниже)
только 1 раз – после завершения сортировки.

публичный статичный метод sortSales в соответствии с приведенным описанием задачи.
Примечание 2. Ты можешь выбрать любой алгоритм и способ сортировки, который позволит добиться заявленной производительности.
Обрати внимание – скорее всего, рассмотренные ранее методы не позволят добиться заявленной производительности.
Воспользуйся поиском в сети Интернет, чтобы найти наиболее эффективные алгоритмы сортировки и реализовать их.
Примечание 3. Не забудь добавить комментарии к фрагменту кода, в которых ты объясняешь суть алгоритма. */

public class Sort_4_new {
    public static void main(String[] args) {
        double[] data = {6.0, 5.0, 4.0, 3.0, 2.0, 1.0, 7.0, 8.0, 0.0};
        String[] names = {"A", "B", "C", "D", "E", "F", "G", "H", "I"};
        printData(names, data);
        sortSales(names, data);
    }

    public static void sortSales(String[] names, double[] data) {
        if (names.length != data.length) {             // Если размеры массивов не равны друг другу, то
            System.out.println("Corrupted Data");      // выводим сообшение, согласно п.1 задачи и
            return;                                    // прекращаем работу метода.
        }
        if (names.length == 0 | data.length == 0) {   // Если массивы не содержат данных, то
            System.out.println("Empty Data");          // выводим сообшение, согласно п.2 задачи и
            return;                                    // прекращаем работу метода.
        }
        int low = 0;
        int high = data.length - 1;
        quickSort(data, names, low, high);
        printData(names, data);
    }

    public static void quickSort(double[] array, String[] array2, int low, int high) {
        // выбрать опорный элемент
        int middle = low + (high - low) / 2;
        double opora = array[middle];
        // разделить на подмассивы, который больше и меньше опорного элемента
        int i = low, j = high;
        while (i <= j) {
            while (array[i] < opora) {
                i++;
            }
            while (array[j] > opora) {
                j--;
            }
            if (i <= j) { //меняем местами
                double temp = array[i];
                array[i] = array[j];
                array[j] = temp;
                String temp2 = array2[i];
                array2[i] = array2[j];
                array2[j] = temp2;
                i++;
                j--;
            }
        }
        // вызов рекурсии для сортировки левой и правой части
        if (low < j)
            quickSort(array, array2, low, j);
        if (high > i)
            quickSort(array, array2, i, high);
    }

    private static void printData(String[] names, double[] data) {
        System.out.print("{");
        for (int i = 0; i < names.length; i++) {
            System.out.print(names[i] + ": " + data[i] + ", ");
        }
        System.out.println("\b\b}");
    }
}
